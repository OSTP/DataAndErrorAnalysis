%Copyright 2016 R.D. Martin
%This book is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
%
%This book is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details, http://www.gnu.org/licenses/.
\chapter{Python}
This chapter is meant to serve as an introduction to programming in python and to be used as a reference. Do not worry about memorizing all of the commands, this will come automatically with practice.

\section{The basics}
This section covers some of the basic syntax in python.
\subsection{Variables and the assignment operator}
In a computer program, one uses ``variables'' and assigns them values. A variable can be thought of as an address inside of the computer's memory that can store a value. If we want to put a value into the computer's memory, we first create a variable and then ``assign'' that variable the desired value. We can then access the value that we stored by telling the program that we are interested in the value that is stored in a particular variable. This is the most basic operation in writing a computer program. In python, the syntax is the following:
\begin{python}[caption=Assignment operator] 
a = 2 
\end{python}

In the above, we have created a variable, \code{a}, and assigned it the value of 2. The equal sign is called the \textbf{``assignment operator''}, and it always ``puts the thing on the right \textbf{into} the thing on the left''. Notice that python automatically recognizes that we are storing a number into the variable \code{a}, and python will thus treat \code{a} like a number. The following code thus has the expected behaviour and the new variable \code{b} will have the number 4 stored.

\begin{python}[caption=Assignment operator] 
a = 2 
b = 2*a
\end{python}

\subsection{Printing to screen}
Now, you may not believe that the variable \code{b} above is actually equal to 4. Luckily, you can ask the computer program to ``print'' out the value that is stored in a variable, by using the \code{print()} function:
\begin{python}[caption=Printing]  
a = 2 
b = 2*a
print(b)
\end{python}
\begin{poutput}
4
\end{poutput}
This will print the value of 4 to the output of the program. \code{print()} is the first example of a function. Functions can take any number of ``arguments'' and then act on them. In this case, we ``passed'' the variable \code{b} to the function \code{print()} (by putting it into the parenthesis) and then the function took care of printing that to the output. The \code{print()} function is quite flexible, and can take any number of arguments of different types, separated by commas:
\begin{python}[caption=Printing multiple items] 
a = 2 
b = 2*a
print("The value of a is",a,"and the value of b is ",b)
\end{python}
\begin{poutput}
The value of a is 2 and the value of b is  4
\end{poutput}
In this case, we passed 4 different arguments to the \code{print()} function. The second and fourth arguments, our variables \code{a} and \code{b}, are numbers. The first and third arguments are what we call ``strings'' (strings of characters), which we must include in quotation marks, so that python does not think that these are variables.

\subsubsection{Formatting numerical output}
Python cannot guess how many decimals it makes sense to display when you print a number; often, you want to control this. This can be done using the \code{format} ``method''.
\begin{python}[caption=Formatted printing] 
a = 2. 
b = 3./2.
c = 2./3.
print("first={:.1f}, second= {:.2f}, third={:.4f}".format(a,b,c))
\end{python}
\begin{poutput}
first=2.0, second= 1.50, third=0.6667
\end{poutput}
The \code{format} method works as follows. You first define a ``template string'' (in the above case, \code{"first=\{:.1f\}, second= \{:.2f\}, third=\{:.4f\}"}) with quotation marks. You then add a \code{.format()} to the end of it. The \code{format()} method will look inside of the string for occurrences of curly brackets (\{\}). Inside of the curly brackets, you can tell it what format you would like for the number: in our case \code{\{:.nf\}} means that we would like to display $n$ decimals (.n) of a floating point number (f). Thus, \code{\{:.4f\}} displays 4 decimals. The final component, is that one tells \code{format()} which numbers we actually want to format that way, by passing those numbers as arguments to \code{format()} in the same order in which we want them to appear in the curly braces. What really happens is that \code{format()} sequentially replace the curly brackets with the ``formatted version'' of the numbers that it is given (in our case, the variables a,b,c).


One particular trick to pay attention to in python, is that it will prefer to think of variables as integers rather than decimal numbers if we do not specify that they are decimal. This can have some unintended consequences, if python mistakenly thinks we want a variable to be a integer instead of a decimal number (a ``float''). To avoid any ambiguity, when we assign a value to a variable, it is good practice to add a decimal point to it so that python will not mistakenly treat it as an integer. Thus, it is best to say \code{a=2.} or \code{a=2.0}, rather than \code{a=2} (unless of course, we intend for \code{a} to be an integer).

\subsection{Comments}
As code becomes more complex, it is important to be able to insert some comments so that we can remember what we did (or so that others can understand what your code is doing). In python, comments are preceded with the number (or pound) sign '\#'\footnote{This is not called a hashtag!}, and anything that follows will be ignored by the computer:
\begin{python}[caption=Using comments]
#Here we have a simple program 
a = 2 #a is set to 2
b = 2*a #b is twice a
#Now we print out the result:
print("The value of a is",a,"and the value of b is",b)
\end{python}
\begin{poutput}
The value of a is 2 and the value of b is 4
\end{poutput}
Always comment your code. You cannot over comment! You would be surprised at how quickly you will forget the logic in your code if you have no comments.
\subsection{Lists}
A particularly useful type of variable in python is the ``list''. This is analogous to ``arrays'' in other programming languages. A list is used to hold, well, a list of values. For example, let's say that we wish to work with a set of measurements, for example radii of circles from example \ref{ex:chapIntro_2pir}, and hold them into a single variable, \code{radii}, we can use a list as follows:
\begin{python}[caption = Defining a list]
radii=[0.9,1.0,0.95,1.1,1.2,1.0,0.8,0.85,1.05,1.0]
\end{python}
Python automatically recognizes that the variable \code{radii} should be a list, since we are trying to assign a set of 10 comma-separated values to it. We can work with the whole list, but we can also get a particular element out of the list, by using the access operator ('{[ ]}') and the index of the element:
\begin{python}[caption = Indexing a list]
radii=[0.9,1.0,0.95,1.1,1.2,1.0,0.8,0.85,1.05,1.0]
print(radii[2])
\end{python}
\begin{poutput}
0.95
\end{poutput}
One thing to note is that the above \code{print()} function printed out the third element of the list and not the second one. This is because \textbf{python indexes the first item in the list with the index 0}. If the list has \code{n} elements in it, then the last element has the index \code{n-1}. If you try to ask for an element that is beyond the size of the list, e.g. \code{radii[10]}, bad things happen. This is because you are really asking for a value stored in the memory of the computer in a location where you have not stored anything. 

A useful operation on a list is to ask how many elements are in the list; this is done with the \code{len()} function:
\begin{python}[caption = Length of a list]
radii=[0.9,1.0,0.95,1.1,1.2,1.0,0.8,0.85,1.05,1.0]
print("We measured",len(radii),"radii")
\end{python}
\begin{poutput}
We measured 10 radii
\end{poutput}

\subsubsection{Operations on lists}
The code below illustrates a variety of operations that can be performed on lists, such as inserting and removing values. Try it for yourself and make sure you understand what is going on.
\begin{python}[caption = Operations on lists]
#a list of numbers
array=[1,2,3,4,5,6]
#len(array) is the number of elements in the list
print("The size of the list is",len(array))
#lists start a 0
print("Element 1 of the list is",array[1])
#You can print a list:
print("The list is:", array)
#You can append an element to the end:
array.append(7)
print("The list is now:",array)
#Remove the 5th element
array.pop(5)
print("The list is now:",array)
#Remove the last element
array.pop()
print("The list is now:",array)
#Insert the number 9 at position 3
array.insert(3,9)
print("The list is now:",array)
#Reverse the elements in the list
array.reverse()
print("The list is now:",array)
#Sort the list
array.sort()
print("The list is now:",array)
#You can mix variable types in the list (even including other lists)
mixedarray=["hello",42,array]
print("The mixed array:",mixedarray)
print("Some elements from it:", mixedarray[0],
      mixedarray[1],mixedarray[2][3])
#You can slice a list to generate a new list
subarray=array[2:4]
print("The sub list:",subarray)
\end{python}
\begin{poutput}
The size of the list is 6
Element 1 of the list is 2
The list is: [1, 2, 3, 4, 5, 6]
The list is now: [1, 2, 3, 4, 5, 6, 7]
The list is now: [1, 2, 3, 4, 5, 7]
The list is now: [1, 2, 3, 4, 5]
The list is now: [1, 2, 3, 9, 4, 5]
The list is now: [5, 4, 9, 3, 2, 1]
The list is now: [1, 2, 3, 4, 5, 9]
The mixed array: ['hello', 42, [1, 2, 3, 4, 5, 9]]
Some elements from it: hello 42 4
The sub list: [3, 4]
\end{poutput}
We should point out that in the second last example, we are accessing a list using two indices. This is because one can nest lists inside of each other. A good analogy is to think of a list as a vector. If each entry in the vector is a vector itself, then we really have a matrix. For example, we can build a 2x3 matrix in the following way:
\begin{python}[caption = Two dimensional lists]
matrix = [[1,2,3],[4,5,6]]
print("The first row:",matrix[0])
print("Element [0][2]:",matrix[0][2])
\end{python}
\begin{poutput}
The first row: [1, 2, 3]
Element [0][2]: 3
\end{poutput}
The \code{matrix} list in this case has 2 elements, and each of those elements is a list of 3 values. \code{matrix[0]} thus refers to the first set of 3 elements, and \code{matrix[0][2]} to the third element of that set. 

\subsection{Types of variables}
We have already seen a few of the different types of variables that python offers (and it typically can infer from the context what type of variable you intend to use). A few common types of variables are:
\begin{itemize}
\item \textbf{integers:} These are signed integer numbers.
\item \textbf{booleans:} These are variables that can be either \code{True} or \code{False}.
\item \textbf{floats:} These are signed decimal numbers; they usually cannot be represented exactly and are subject to round-off errors.
\item \textbf{strings:} These are ``strings'' of characters and the value of the variable is always surrounded by quotes (single or double). For example \code{"someNumber"} is interpreted as a string, whereas \code{someNumber} is interpreted as a variable (that could be of any type).
\item \textbf{lists:} These are arrays of variables; each element in the array does not have to be of the same type, and lists can be nested. Elements in a list have a well defined position in the list and can be reference by using their index (e.g. \code{array[2]} is the third element of a list since the first element has index 0).
\item \textbf{dictionaries:} These are similar to lists, but instead of referencing elements by a numbered index, they are referenced by a string (which we call the ``key''). Technically, the key does not need to be a string, but it has to be ``non-mutable''; a string is just the most common usage case. Each key must be unique. Dictionaries use curly braces when they are defined. For example, \code{students = \{'bob':123,'jane':456\}}, and are referenced using square braces: \code{sn=students['bob']}. 
\item \textbf{tuples:} These are values that are grouped together with a parenthesis and can be indexed in a way similar to a list.
\item \textbf{objects:} These are more complex data types that can be user defined, for example, one could define a ``student'' object with a variety of properties (name, student number, grades) and write code that directly manipulates the objects. Strings and lists are actually objects in python, and that is why they have many available functions to manipulate them.
\end{itemize}

\section{Controlling the flow}
At this point, we can do some basic calculations and pretty much anything that a calculator can do. However, we cannot do anything very complex without controlling the flow of our program. This section introduces a few key ways to control the flow of the program.
\subsection{Scope}
In python, we can define small little units of code that are only executed in certain conditions. Those units of code are \textbf{preceded by a line that ends with a colon (':') and must be indented to the right} compared to the rest of the code. We say that the part of the code that is indented forms a `scope';  whatever happens in the scope, stays in the scope, just like Vegas. Scopes can be nested within each other. Variable that are defined inside of a scope cease to exist outside the scope. Variables that are defined before and outside of a scope, are accessible in that scope. 

\subsection{If-statements}
One of the most useful types of scope, is the scope defined by an ``if-statement''. Code inside the scope of an if-statement is executed only if the if statement evaluates to the boolean value \code{True}:
\begin{python}[caption = If statements]
#define 3 variables:
a = 2 
b = 3
c = 4
if b > a: #True
  print("b is bigger than a")
if c < a: #False
  print("c is smaller than a")
if 2*a == c: #True
  print("2a is equal to c")
\end{python}
\begin{poutput}
b is bigger than a
2a is equal to c
\end{poutput}
In this case, the code inside the scope of the second if-statement is never executed, because the condition before the colon is False. The greater and lesser than symbols are pretty obvious, but note the use of the double equal sign, \code{==}, to test if two values are equal. This is because the single equal sign is already taken (it is the assignment operator), so if we want to test if two things are equal, we must use the ``equality operator'', \code{==}.

\subsection{Loops}
The other very useful type of scope is the ``loop''. This is where computers really excel at doing repetitive tasks. The most common type of loop is the ``for'' loop, which defines a scope that is executed a specified number of times. A common application is to ``loop'' through all the elements inside of a list. For example:

\begin{python}[caption = For in loops]
radii=[0.9,1.0,0.95,1.1,1.2,1.0,0.8,0.85,1.05,1.0]
for r in radii:
  print("r =",r)
\end{python}
\begin{poutput}
r = 0.9
r = 1.0
r = 0.95
r = 1.1
r = 1.2
r = 1.0
r = 0.8
r = 0.85
r = 1.05
r = 1.0
\end{poutput}

Again, the syntax is similar as that for the if-statment. We first have a statement that defines the loop and ends with a colon, followed by a section that is indented to the right (the scope of the for loop). In this case, the \code{for r in radii} statement means the following: ``Create a new variable called \code{r}, and then execute the code in the scope one time for each value inside of \code{radii}, assigning that value to \code{r} each time''. This particular example will print all of the values inside of the list.

A useful function for loops is the \code{range()} function. In its most basic implementation (when passed only 1 argument, \code{n}) it returns a list of numbers from 0 to \code{n-1}. This makes is particularly easy to loop through a list using the index of the elements:

\begin{python}[caption = For loop with range]
radii=[0.9,1.0,0.95,1.1,1.2,1.0,0.8,0.85,1.05,1.0]
n = len(radii)
for index in range(n):
  #the variable index will have values 0..9
  print("Element",index,"has value:", radii[index])
\end{python}
\begin{poutput}
Element 0 has value: 0.9
Element 1 has value: 1.0
Element 2 has value: 0.95
Element 3 has value: 1.1
Element 4 has value: 1.2
Element 5 has value: 1.0
Element 6 has value: 0.8
Element 7 has value: 0.85
Element 8 has value: 1.05
Element 9 has value: 1.0
\end{poutput}

\begin{example}{Use a for loop to create 2 lists that hold the numbers from 1 to 100 and their squares, respectively}{}
\begin{python}[caption = Loop example]
numbers=[] # an empty list that we will fill
squares=[]
for index in range(100):
  x=index+1 # since the first value is 0
  numbers.append(x)
  squares.append(x*x)
print("the numbers are:",numbers)
print("the squares are:",squares)
\end{python}
\end{example}
\section{Defining custom functions}
We have already encountered a few functions; \code{print()} and \code{range()}. Functions may take ``arguments'' (they don't have to), typically would do something (using the arguments if applicable), and may return a value (but they don't have to). Functions are extremely useful, especially as a way to make your code re-usable and to avoid re-writing the same code over and over. 

You must first define a function before you can use it. Defining a function is a way for you to personalize python and give it additional functionality. Let's write a simple function to return the factorial of a number
\begin{python}[caption = Defining a custom function]
#define the factorial function
def factorial(n):
    fact=1 # keep track of the factorial
    for i in range(n):
        fact = fact*(i+1) #+1 because the first i is zero
    return fact
\end{python}
Functions are defined using the \code{def} statement, followed by the name of the function (\code{factorial} in this case) and then, if applicable, the arguments that the function needs in parenthesis. The statement ends with a colon and the next line is indented. This defines the scope of the function. To calculate the factorial, we declared a variable that will hold our result (\code{fact}). We then needed to do a for loop to calculate the factorial. Finally, outside of the scope of the for loop but still inside the scope of the function, we used the \code{return} statement to pass the calculated number (\code{fact}) out of the function. The function can then be used as follows:
\begin{python}[caption = Using a custom function]
print("3 factorial is",factorial(3))
print("10 factorial is",factorial(10))
\end{python}
\begin{poutput}
3 factorial is 6
10 factorial is 3628800
\end{poutput}
You have now added the functionality of calculating factorials into python!

Functions need not take an argument or return a value, for example:
\begin{python}[caption = Functions with no return values]
#define a function to print a warning
def printWarning():
  print("Hey, you should be warned here")

#use the function:
printWarning()
\end{python}
\begin{poutput}
Hey, you should be warned here
\end{poutput}

Functions can also return multiple values (as a tuple):
\begin{python}[caption = Functions with multiple return values]
#define a function of 1 argument
def squareCube(x):
  #return a tuple
  return x*x, x*x*x

#use the function to assign values to 2 variables
x2 ,x3 =squareCube(5)

print("5 squared is",x2,", 5 cubed is",x3)
\end{python}
\begin{poutput}
5 squared is 25 , 5 cubed is 125
\end{poutput}
In reality, python is not actually returning multiple values, but rather it is bundling the two values into a tuple. In practice, you can however pretend that it is in fact returning multiple comma-separated values.

\section{Importing modules}
Fortunately, many have come before us to write a lot of useful functions, and made them available for us to use. Python comes already bundled with a large amount of functions already written for us, and these are available through ``modules''. In order to be able to use the functions inside of a module, you must ``import'' the module. This is typically done at the top of your program. For example, the \code{math} module has a large number of functions for doing math. To use the square root function for example, you would import the math module as follows:
\begin{python}[caption = Importing the math module]
import math
a=2
sqrta = math.sqrt(a)
print("the square root of a is ",sqrta)
\end{python}
\begin{poutput}
the square root of a is  1.4142135623730951
\end{poutput}
We may also find it useful to change the name of a package when we import it (e.g. to make it shorter if we have to type it a lot). In this case, we can use the \code{import ... as} format:
\begin{python}[caption = Importing a module as]
import math as m
a=2
sina = m.sin(a)
print("the sin of a is ",sina)
\end{python}
\begin{poutput}
the sin of a is  0.9092974268256817
\end{poutput}
There are other ways to ``import'' functions from modules, but the above ways are the most explicit (that is, it is clear when you call the function \code{math.sqrt()} that the function belongs to the math module).

For completeness, other equivalent ways to achieve the same functionality are:
\begin{python}[caption = Import everything from a module]
from math import *
a=2
sqrta =sqrt(a) # don't need the math. in this case
print("the square root of a is ",sqrta)
\end{python}
\begin{poutput}
the square root of a is  1.4142135623730951
\end{poutput}
which imports all functions from the math module and makes them available directly (without needing the \code{math.}), or:
\begin{python}[caption = Importing a single function from a module]
from math import sqrt
a=2
sqrta =sqrt(a) # don't need the math. in this case
print("the square root of a is ",sqrta)
\end{python}
\begin{poutput}
the square root of a is  1.4142135623730951
\end{poutput}
which imports only the \code{sqrt} function (so for example, \code{sin(a)}) would not work.

It is very easy to create your own modules. Simply place the definitions of your functions into a file called 'mymodule.py' (where 'mymodule' can be whatever name you choose), and you can then use them by simply typing \code{import mymodule} (without the '.py'). For example, you may have a file called 'errorAnalysis.py' with the following content:
\begin{python}[caption = Defining your own module]
def factorial(n):
    fact=1 # keep track of the factorial
    for i in range(n):
        fact = fact*(i+1) #+1 because the first i is zero
    return fact
    
def squareCube(x):
  #return a tuple
  return x*x, x*x*x    
\end{python}
and you can then use these functions in a program:
\begin{python}[caption = Importing your own module]
import errorAnalysis

print("8 factorial is:",errorAnalysis.factorial(8))
print("square and cube of 5 are:",errorAnalysis.squareCube(5))
\end{python}
\begin{poutput}
8 factorial is: 40320
square and cube of 5 are: (25, 125)
\end{poutput}
There a lot of modules available in python, some are included directly and many can be downloaded from the internet. Do not be afraid to search the internet for modules that may be of use; chances are that if you have something you need done, someone has already written a module for it.
\section{Reading and writing data files}
Reading and writing data from and to files is very useful, as opposed to directly ``hardcoding'' data into a program (as we did above for the radii). This is useful if we have a large number of measurements that all need to be analysed in the same way or if the data themselves were already written into a file by a data acquisition system.

Let's say that we have a text file with the following data in it (representing measurements of radius and circumference from an experiment like that in example \ref{ex:chapIntro_2pir}), and let's assume the file is named 'radcirc.dat':
\begin{verbatim}
0.9   5.4
1.0   6.2
0.95   6.2
1.1   5.9
1.2   7.9
1.0   6.0
0.8   5.1
0.85   4.8
1.05   6.7
1.0   6.5
\end{verbatim}
The data are in 2 columns, one for radius and one for circumference. We now wish to read these values into our program, compute 2$\pi$r from the radius, compare that with the measured circumference, and then output the difference to a new file, called 'results.dat'. This can be done with the following code:
\begin{python}[caption = Reading and writing to a file]
import math #because we need pi, and it's defined in math

#open the file with the data, need quotation marks on the file name!
dataFile = open('radcirc.dat', 'r') #open in read mode

#open the file to write the output:
resultFile = open('results.dat','w') #open in write mode

#loop over each line in the file:
for line in dataFile:
  #line contains both numbers, so we split them up into list
  lineData = line.split()
  #take each value from the list and put them into new variables
  #we need to convert them to numbers (float) because python assumes
  #that they are strings of characters:
  r=float(lineData[0])
  circ=float(lineData[1])
  
  #the predicted circumference is:
  predicted=2*math.pi*r
  
  #the difference with measured one is:
  difference=predicted - circ
  print(difference, file=resultFile)

\end{python}
The file 'results.dat' now contains a single column with the differences between the predicted and measured circumferences. You can see that we used the \code{print()} function, with an additional ``named argument'' to specify that we would like to print to the file, rather than to the screen; in this case, we passed our file variable (\code{resultFile}) to the argument that is named \code{file}.

If you look at the file 'results.dat', you will find that the numbers have more decimal places that would really be considered significant. We can thus use the \code{format()} method to clean it up.

\begin{python}[caption = Reading and writing to a file with formatted data]
import math #because we need pi, and it's defined in math

#open the file with the data, need quotation marks on the file name!
dataFile = open('radcirc.dat', 'r') #open in read mode

#open the file to write the output:
resultFile = open('results.dat','w') #open in write mode

#loop over each line in the file:
for line in dataFile:
  #line contains both numbers, so we split them up into list
  lineData = line.split()
  #take each value from the list and put them into new variables
  #we need to convert them to numbers (float) because python assumes
  #that they are strings of characters:
  r=float(lineData[0])
  circ=float(lineData[1])
  
  #the predicted circumference is:
  predicted=2*math.pi*r
  
  #the difference with measured one is:
  difference=predicted - circ
  print("{:.2f}".format(difference), file=resultFile)

\end{python}


\section{Modules of use in scientific computing}

Data science needs in industry have led to the rapid development of python modules for data analysis. Traditionally, programming languages like python, which are ``interpreted'' on the fly as the computer tries to run the code, are slower at processing numbers than compilable languages like C++. In order to alleviate this issue somewhat, people have programmed modules that provide ``pythonic'' (easy to program) interfaces for dealing with numbers that, behind the scenes, are much more efficient than regular python code. These interfaces basically figure out what the user is trying to accomplish and then run the calculations using C++ code before passing the result back in python. Some of these interfaces are quite complex and actually allow the code to be run on highly efficient graphical processing units (graphics card); these are highly optimized for matrix algebra and anything where parallel computations are efficient.

The other aspect of data analysis that is often needed is a way to visualize data and make graphs, and there are a variety of modules for that as well. 

A common module (actually, a set of modules) for scientific work in python is ``scipy''. Scipy (a ``stack'' of modules), comes with most scientific python packages (such as Anaconda, Python(x,y), etc.) and includes modules for plotting (matplotlib), scientific calculations (scipy), symbolic math (sympy), efficiently using arrays of number (numpy), and others. We will give a brief overview of numpy and matplotlib since they are the most useful in our context.

\subsection{Working with numbers, numpy}
In scientific computing, we work predominantly with numbers, and usually a lot of them (think of a list of measurements). We already saw that the python list is a handy way to hold an array of numbers. The list has a lot of useful functions (e.g. dynamically changing the size of the list, searching) that are not very useful in numerical computation, and this added functionality makes lists inefficient for scientific computing. At the core of the numpy module is a type of array that is much more efficient than lists for dealing with numbers. All of the elements in a numpy array must be of the same type. Numpy arrays can also be mult-dimensional (e.g. a matrix or tensor). There are also a variety of functions that can act on numpy arrays, to fill them, evaluate properties about them, and change their shape. Here are a few examples:

\begin{python}[caption = The numpy module for arrays]
# We import numpy (and by convention shorten it to np, since
# we use it a lot)
import numpy as np

# a simple one-dimensional array
a = np.array([1,2,3,4,5,6])

# we can print the array and see its "shape":
print("The array is",a," and has shape:",a.shape, "and the second element is ", a[1])
print("The size of the array is",a.size)

#we can change the shape to be 2D, e.g. 2x3:
a=a.reshape(2,3)
print("The array is :\n",a,"\n and has shape:",a.shape)

#we access an element of a two d array as expected:
print("The 1,2 element is",a[1][2])
print("The size of the array is",a.size)

#we can create an array full of zeroes:
#we specify the shape of the array with a tuple (hence the extra parenthesis)
z=np.zeros( (4,5) ) # 4 by 5 array of zeros
print("Zeroes: \n", z)

#we can create an array full of ones:
#for a 1D array, no need to use a tuple for the shape
o=np.ones(10) # array of 10 times the number 1
print("Ones:",o)

#an array with numbers in a certain range:
seq1 = np.arange(10,30,5) #numbers from 10 to 30 spaced by 5
print("Sequence 1:", seq1)

#if using floats, better to use linspace
seq2 = np.linspace(0,10,11) #11 numbers from 0 to 10
print("Sequence 2:", seq2)
\end{python} 
\begin{poutput}
The array is [1 2 3 4 5 6]  and has shape: (6,) and the second element is  2
The size of the array is 6
The array is :
 [[1 2 3]
 [4 5 6]] 
 and has shape: (2, 3)
The 1,2 element is 6
The size of the array is 6
Zeroes: 
 [[ 0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.]]
Ones: [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]
Sequence 1: [10 15 20 25]
Sequence 2: [  0.   1.   2.   3.   4.   5.   6.   7.   8.   9.  10.]
\end{poutput}

Numpy has a lot of more advanced useful features, such as the ability to directly load a file into an array, to write an array into a file, to calculate properties of the array, and to manipulate arrays. Following, are a few advanced examples for reference.

\subsubsection{Reading and writing to file}
Here is a simple way to read and write a numpy array directly to a file. In this example, it uses the default format, which is to separate entries in the file with a space. One can specify different delimiters, such as commas, if preferred.
\begin{python}[caption = Reading and writing numpy arrays from/to a file]
import numpy as np

#make a 4x5 array from random numbers that are normally distributed
a=np.random.normal(7,1,(4,5)) #mean = 7, stdev = 1, shape=(4,5)
print("a:\n",a)

#now save to file (with 2 decimal places)
#for Windows, need the '\r\n', otherwise, '\n' works on Mac and Linux:
np.savetxt('normaldist.dat',a, fmt='%.2f',newline='\r\n')

#read from file:
b=np.loadtxt('normaldist.dat')
print("b:\n",b)
\end{python} 
\begin{poutput}
a:
 [[ 7.72906707  7.58554688  6.55403963  8.204429    6.36589465]
 [ 6.32161056  6.46633883  6.94348052  6.16305886  8.22179026]
 [ 7.13446799  6.99732091  5.98000653  7.58423135  6.75268651]
 [ 6.28267233  8.28811545  6.97310529  9.60489909  8.2377974 ]]
b:
 [[ 7.73  7.59  6.55  8.2   6.37]
 [ 6.32  6.47  6.94  6.16  8.22]
 [ 7.13  7.    5.98  7.58  6.75]
 [ 6.28  8.29  6.97  9.6   8.24]]
\end{poutput}

\subsubsection{Calculating properties of an array}
Numpy includes some basic functions to calculate simple properties of arrays (such as the mean of the elements or the sum of the elements):
\begin{python}[caption = Numpy for statistical properties of an array of values.]
import numpy as np

#make an array of 15 random numbers that are normally distributed
a=np.random.normal(7,1,15) #mean = 7, stdev = 1, shape = 15
print("a:\n",a)

#the average of those numbers and the standard deviation:
print("The mean is ",a.mean()," the standard deviation is: ",a.std(ddof=1))

#the sum of those numbers:
print("The sum is ",a.sum()," and the average is thus: ",a.sum()/a.size)
\end{python} 
\begin{poutput}
a:
 [ 7.46161595  7.69000179  5.89548669  7.01653231  5.79241436  6.50478794
  7.90049186  7.35861676  7.94790841  7.0088528   7.25540553  6.93505626
  9.12845098  5.97135201  6.9343631 ]
The mean is  7.12008911701  the standard deviation is:  0.882240259864
The sum is  106.801336755  and the average is thus:  7.12008911701
\end{poutput}

\subsubsection{Operations on arrays}
Numpy arrays can be used in computations (e.g. multiplying or summing arrays together) and operated on with numpy functions (such as taking the square root of all elements).
 
\begin{python}[caption = Numpy operations on arrays]
import numpy as np

#make two arrays of numbers
a=np.linspace(1,5,5)
b=np.linspace(6,10,5)
print("a: ",a)
print("b: ",b)

#add arrays together, element by element:
sumAB=a+b
print("sum: ",sumAB)

#multiply, element by element:
productAB=a*b
print("product: ",productAB)

#multiply all elements by a scalar:
twoA=2*a
print("2 times a: ",twoA)

#apply a function to elements:
squareA=np.square(a)
print("a squared: ",squareA)
\end{python} 
\begin{poutput}
a: [ 1.  2.  3.  4.  5.]
b: [  6.   7.   8.   9.  10.]
sum: [  7.   9.  11.  13.  15.]
product: [  6.  14.  24.  36.  50.]
2 times a: [  2.   4.   6.   8.  10.]
a squared: [  1.   4.   9.  16.  25.]
\end{poutput}

You can even define a function that is can act on both arrays or on regular numbers. For example, the following will add two numbers ``in quadrature'', or if given two arrays as inputs, it will return an array of the values added in quadrature:
\begin{python}[caption = Defining a function to operated on a numpy array]
import numpy as np
#Define a simple function to add two numbers in quadrature:
def addInQuad (e1,e2):
  return np.sqrt(e1*e1+e2*e2)

print("2 and 3 added in quadrature is ",addInQuad(2,3))

#make two arrays of numbers
a=np.linspace(1,5,5)
b=np.linspace(6,10,5)
print("a:",a)
print("b:",b)

#c is an array where each element is the elements of a and b 
#added in quadrature
c=addInQuad(a,b)
print("c:",c)
\end{python} 
\begin{poutput}
2 and 3 added in quadrature is  3.60555127546
a: [ 1.  2.  3.  4.  5.]
b: [  6.   7.   8.   9.  10.]
c: [  6.08276253   7.28010989   8.54400375   9.8488578   11.18033989]
\end{poutput}
\subsection{Making plots with matplotlib and pylab}
Visualizing data is an important way to understand them. The \code{matplotlib} module is the most popular module for plotting and visualizing data in python. The \code{pylab} module uses the \code{matplotlib} module and adds some functionality to give it a Matlab feel (importing \code{pylab} is actually equivalent to importing both \code{matplotlib} and \code{numpy}). When searching for help on the internet for plotting, it may be useful to search for \code{matplotlib} or \code{pyplot} rather than \code{pylab}, as those are the modules that do the actual plotting.

\subsubsection{Scatter plot and plotting a function}
Matplotlib can easily plot the data from numpy arrays. The \code{plot} function takes as its first two arguments arrays of the same length containing the $x$ and $y$ coordinates of points to plot. The function can take additional optional arguments to specify the looks of the plot (whether to use points or an interpolated line, what color to use, a possible label, etc.).

The following code produces a simple plot of the sine and cosine functions, by building numpy arrays to hold the values and then plotting them (the result is shown in Figure \ref{fig_chapPyton_sincos}):

\begin{python}[caption = Pylab to make a scatter plot and plot a function]
import numpy as np
import pylab as pl
import math 

#create  and array holding values between 0 to 2pi
x=np.linspace(0,2*math.pi,50) #values of x

#use the fact that we can operate element-wise on a whole array, to create
#arrays with value of sin and cos:
y=np.sin(x)
z=np.cos(x)

#plot (x,y) and (x,z)
pl.plot(x,y,label="sin(x)") #default is a blue line
pl.plot(x,z,'ro',label="sin(x)") #plot red circles ('ro') instead

#make it pretty:
pl.xlabel("angle in radians")
pl.ylabel("sin or cos")
pl.title("Trig functions")
pl.legend(loc='upper center')
pl.grid(True)

#show the plot:
pl.show()
\end{python} 
\begin{poutput}
(* \capfig{0.7\textwidth}{figures/sincos.png}{\label{fig_chapPyton_sincos}Two data sets plotted with a legend.} *)
\end{poutput}
\subsubsection{Plot with error bars}
The \code{errorbar()} function allows us to plot a set of data points with error bars. The function expects the first two arguments to be numpy arrays of the $x$ and $y$ coordinates of the data points, and the error bars on those points can be specified using the \code{xerr} and \code{yerr} keywords. The error bars can be specified as arrays (thus each point could have different sized error bars), or as a constant number (all points then having the same errorbar). The result is shown in Figure \ref{fig_chapPyton_sinerrors}.

\begin{python}[caption = Pylab to make a plot with error bars]
import numpy as np
import pylab as pl
import math 

#plot (x,y) 
x=np.linspace(0,2*math.pi,50) # 50 values between 0 and 2pi
y=np.sin(x)

#let's add variable errors in y and fixed errors in x
dy=0.2*np.sqrt(np.abs(y)) #variable errors in y
dx=0.1 #constant error bards in x

pl.errorbar(x,y,yerr=dy,xerr=dx, fmt='o') 
pl.title("Plot with error bars")
pl.show()

\end{python} 
\begin{poutput}
(* \capfig{0.7\textwidth}{figures/sinerrors.png}{\label{fig_chapPyton_sinerrors}Data set with constant $x$ and variable $y$ error bars.}*)
\end{poutput}

\subsubsection{Plotting histograms}
\label{subsub:pythonhist}
A particularly useful way to plot data of a statistical nature is the ``histogram'' (See Chapter \ref{Chap:statData} for details on histograms). This is done very easily with the \code{hist()} function. (see Fig. \ref{fig_chapPyton_normal}):

\begin{python}[caption = Pylab to plot a histogram]
import numpy as np
import pylab as pl
import math 

#create a set of normally distributed random numbers
x=np.random.normal(7,1,1000)

#histogram the values
n,bins,patches=pl.hist(x,bins=40)

#Make it pretty:
pl.xlabel("value")
pl.ylabel("frequency of value")
pl.title("Normally distributed variable")

#Set the axis range
pl.axis([0,12,0,80])

#show the plot:
pl.show()

\end{python} 
\begin{poutput}
(* \capfig{0.7\textwidth}{figures/normal.png}{\label{fig_chapPyton_normal}Histogram with 40 bins of random values normally distributed with a mean of 7 and standard deviation of 1.} *)
\end{poutput}

The \code{hist()} function plots the histogram and returns a tuple \code{(n,bins,patches)}. The first element in the tuple (\code{n}) is an array containing the number of counts in each bin, the second element (\code{bins}) is an array with the left edge of each bin, and the third element (\code{patches}) contains information on drawing the actual histogram (e.g. where to place rectangles) and has no analysis use for us.

The \code{hist()} function takes as first argument the array of values that it should histogram, and it can take a variety of other arguments to control the display of the histogram. A particularly important argument is the \code{bins} argument, which controls the binning of the histogram. If this is a single number, then python will automatically figure out the range of values in the array and create that many equal bins (40 bins in the example above). One can also specify \code{bins} by setting it equal to an array of values which correspond to the left side of the bins that we specify (and the last value in the array in the right edge of the highest bin). For example:
\begin{python}[caption = Making a histogram with customized bins]
#histogram the values
n,bins,patches=pl.hist(x,bins=[6.5,7,7.1,7.2,7.3,7.4,7.5,8])
\end{python}
would create a histogram with only a subset of the data (from 6.5 to 8), with two wider bins on either side (from 6.5 to 7 and from 7.5 to 8), and a set of smaller bins between 7 and 7.5.

There are also a variety of options for controlling the look of the histogram, and these can be combined onto a single plot, as below, which produces Figure \ref{fig_chapPyton_normal_demo}.
\begin{python}[caption = Plotting multiple histograms]
import numpy as np
import pylab as pl
import math 

#create a set of normally distributed random numbers
x=np.random.normal(7,1,1000)

#histogram the values with different binning and different styles
pl.hist(x,bins=40,alpha=0.5,color='red',histtype='stepfilled',label='40 regular bins') #alpha makes it translucent...
pl.hist(x,bins=[6.5,7,7.1,7.2,7.3,7.4,7.5,8],alpha=0.5,color='blue',label='7 uneven bins')
#Make it pretty:
pl.xlabel("value")
pl.ylabel("frequency of value")
pl.title("Normally distributed variable - different binning")
pl.legend()
pl.grid()

#Set the axis range
pl.axis([3.5,10.5,0,250])
#show the plot:
pl.show()
\end{python}
\begin{poutput}
(* \capfig{0.7\textwidth}{figures/normal_demo.png}{\label{fig_chapPyton_normal_demo}Two different histograms of the same data, with different binning.} *)
\end{poutput}

We can also normalize the histograms (so that the sum of the bin contents is 1), and we can also plot the ``cumulative'' histogram (where each bin is the sum of the bin contents that are below it). The cumulative histogram is effectively the integral of a histogram. The code below illustrates some of the various possibilities for plotting histogram, and also shows how to make ``sub-plots'' in python (which does not apply only to histograms).
\begin{python}[caption = Making a normalized histogram and making sub figures]
import numpy as np
import pylab as pl
import math 

#create a set of normally distributed random numbers
x=np.random.normal(7,1,1000)

#Choose the size of the figure:
pl.figure(figsize=(8,8))

#Create different sub plots:
#Available colours by name are the standard "html colours"
pl.subplot(221)
pl.hist(x,bins=40,color='gray',histtype='step')
pl.title("basic histogram")
pl.xlabel("value")
pl.ylabel("frequency of value")

pl.subplot(222)
pl.hist(x,bins=40,color='burlywood',histtype='stepfilled',normed=True,label='40 bins')
pl.hist(x,bins=10,color='darkslateblue',alpha=0.5,histtype='bar',normed=True,label='10 bins')
pl.title("normalized")
pl.xlabel("value")
pl.ylabel("frequency of value")
pl.legend(loc='upper left',prop={'size':8})

pl.subplot(223)
pl.hist(x,bins=40,color='darkgoldenrod',alpha=0.5,histtype='stepfilled',normed=True,cumulative=True)
pl.title("normalized and cumulative")
pl.xlabel("value")
pl.ylabel("integral of value")

pl.subplot(224)
pl.hist(x,bins=40,color='chocolate',histtype='stepfilled', log=True)
pl.grid()
pl.title("basic - log scale")
pl.xlabel("value")
pl.ylabel("frequency of value")

#show the figure:
pl.tight_layout() #space out the sub plots
pl.show()
\end{python}
\begin{poutput}
(* \capfig{0.8\textwidth}{figures/normal_subplot.png}{\label{fig_chapPyton_normal_subplot}Various ways to display a histogram, also showing how to use subplots.} *)
\end{poutput}

\subsection{Sympy: Symbolic computations in python}
In later chapters, we will find that we often need to take derivatives of quantities. As in other popular software packages, it is also possible to evaluate derivatives symbolically in python. This is done using the \code{sympy} (``symbolic python'') package. 

In order to use symbolic computation, one must first import the sympy package, and then define variable that python will represent as symbols. In this example, we define $x$ and $y$ as symbols, as well as a symbolic function $f(x,y)=\sqrt{x^2+y^2}$, that depends on $x$ and $y$:

\begin{python}[caption = Sympy for symbolic computations in python]
import sympy as sym
x,y = sym.symbols('x y')  #declare variables x and y to be used as symbols
f = sym.sqrt(x**2+y**2) #a function of x and y
\end{python}

The derivatives of $f$ with respect to $x$ and $y$ can be found easily, and manipulated as a symbolic expressions themselves (which we sum below):
\begin{python}[caption = Using sympy to compute a symbolic derivative]
import sympy as sym
sym.init_printing()

x,y = sym.symbols('x y')  #declare variables x and y to be used as symbols
#When we use a function, such as sqrt, we should use the version from the sympy package:
f = sym.sqrt(x**2+y**2) #a function of x and y
#take the partial derivatives of f
dfdx = sym.diff(f,x)
dfdy = sym.diff(f,y)
print("df/dx=",dfdx,"df/dy=",dfdy)
#add them together
dSum = dfdx+dfdy
print("df/dx+df/dy = ",dSum)
\end{python}
\begin{poutput}
df/dx= x/sqrt(x**2 + y**2) df/dy= y/sqrt(x**2 + y**2)
df/dx+df/dy =  x/sqrt(x**2 + y**2) + y/sqrt(x**2 + y**2)
\end{poutput}

Finally, we can also substitute in numerical values using the \code{subs()} command on an expression and passing it an array of tuples. We can numerically evaluate an expression using \code{N()}:
\begin{python}[caption = Substituting numerical values into expressions from sympy]
#substitute some numbers for x and y into our dSum expression
nValue1 = dSum.subs([(x,2),(y,3)])
nValue2 = dSum.subs([(x,4),(y,5)])
print("value 1: {:.2f}, value 2: {:.2f}".format(sym.N(nValue1),sym.N(nValue2)))
\end{python}
\begin{poutput}
value 1: 1.39, value 2: 1.41
\end{poutput}

\subsection{Curve fitting with scipy optimize}

It is often the case that given a set of data points, $(x_i,y_i)$, we want to ``fit'' a model function, $y=f(x,\vec\beta)$, to the data. The goal is to determine the set of parameters $\vec\beta=(\beta_1, \beta_2,\dots)$ that best fit the data. For example, a set of data may be described by a second order polynomial, $f(x)=a+bx+cx^2$, and we may wish to use the data to determine the parameters, $a$, $b$, and $c$ that best fit the data. This can be done using the \code{scipy.optimize} module. The first thing to do is to define a python function to represent our model function:
\begin{python}[caption = Defining a function to use for fitting]
import numpy as np
def model(x,*pars):
    return pars[0]+pars[1]*x+pars[2]*x*x
\end{python}
where you should note that the dependent variable, $x$, is the first argument of the model function, whereas we passed the parameters as a list, \code{*pars}, after the dependent variable.

Let us assume that our data is stored into three one-dimensional numpy arrays, \code{xdata}, \code{ydata}, and \code{ydataErr}, holding the $x$ and $y$ coordinates of the points, and the uncertainties on the $y$ values, respectively. The algorithm that varies the model parameters can have some difficulties in finding good fit values for the fit parameters, especially if the fit function is complicated. It is thus often necessary to give the fitter an initial guess for the parameters. The fitter is run with the following code:

\begin{python}[caption = Fitting a function to a set of xy data with error bars]
from scipy.optimize import curve_fit
#Guesses for the parameters
pars_guess = [5,50,-3]
pars_fit, pcov = curve_fit(model, xdata, ydata,sigma=ydataErr,p0=pars_guess)
\end{python}
where we imported only the \code{curve\_fit()} function from the \code{scipy.optimize} module. The \code{curve\_fit()} function returns a tuple, \code{pars\_fit,pcov}, where \code{pars\_fit} are the best fit values for the parameters that we want and \code{pcov} is the covariance matrix of the parameters. The square root of the diagonal elements of the covariance matrix correspond to the errors on the parameters from the fit, which we can easily get:
\begin{python}[caption = Obtaining the errors from the fit]
#Get the errors out of the covariance matrix
pars_err = np.sqrt(np.diag(pcov))
\end{python}

Below is a full example that creates ``fake data'', fits those data to the model, and then makes a plot showing the fitted function, the data, and the residuals from the fit (see Chapter \ref{Chap:statModelData}, the residuals are the difference between the data and the model evaluated with the best fit parameters).
\begin{python}[caption = A complete fit including residuals]
import numpy as np
import pylab as pl
import matplotlib.gridspec as gridspec  # for unequal plot boxes
from math import *
from scipy.optimize import curve_fit #for fitting

#Define our model function, that depends on x and the parameters that we want to determine
def model(x,*pars):
    return pars[0]+pars[1]*x+pars[2]*x*x

######################
#Create the fake data#
######################
#True values for the parameters, that we use to generate the data:
pars_true=[5,50,-3]

#generate x-values of the data:
ndata = 50 #number of data points
xdata = np.linspace(0,10,ndata)

#generate y coordinates that are normally distributed about the model evaluated at xdata
#with a sigma of yerr
yerr=5*np.ones(xdata.size)#5 #the uncertainty on y values
ydata = np.random.normal(model(xdata,*pars_true),yerr)

#Guesses for the parameters (use the true values here)
pars_guess = pars_true

##############
#Run the fit:#
##############
pars_fit, pcov = curve_fit(model, xdata, ydata,sigma=yerr,p0=pars_guess)

#Get the errors out of the covariance matrix (sqrt of the diagonal elements)
pars_err = np.sqrt(np.diag(pcov))

#Create some text with the fit results to put into our plot
resultTxt = '''Fitted parameters for:
y=a+bx+cx^2:\n'''
parNames = ["a","b","c"]
for i in range(pars_fit.size):
    resultTxt = resultTxt+"{:s}: {:.2f} +/- {:.2f}\n".format(parNames[i],pars_fit[i],pars_err[i])

#########################################################    
#Plot the data with error bars and the result of the fit#
#Also include a subplot with the residuals              #
#########################################################

#Generage a curve from the model and the fitted parameters
yfit = model(xdata,*pars_fit)
#Generate a set of residuals for the fit
yres = ydata-yfit

#Set the size of the figure
pl.figure(figsize=(8,8))
#Divide the figure into 2 rows, with 1 row 3 times higher for the data
gs = gridspec.GridSpec(2, 1, height_ratios=[3, 1])
pl.subplot(gs[0])
#Plot the data with error bars
pl.errorbar(xdata,ydata,yerr=yerr,fmt='o',label='data',color='black')
#Plot the fit line
pl.plot(xdata,yfit,'r',label='fit',lw=3)
#Set the axes range to be pretty:
pl.axis([xdata.min()-1,xdata.max()+1,ydata.min()-yerr[0]-1,1.1*ydata.max()])
pl.legend(loc='upper left')
#Placement of the textbox may not be ideal:
pl.text(xdata.mean(),ydata.min(),resultTxt,fontsize=14)
pl.title("Fit of the data")
pl.xlabel('x')
pl.ylabel('y')
#Use the bottom row of the figure for the residuals:
pl.subplot(gs[1])
pl.errorbar(xdata,yres,yerr=yerr,fmt='o',color='black')#residuals
pl.ylabel('residuals')
pl.xlabel('x')
pl.axis([xdata.min()-1,xdata.max()+1,-5*yerr.max(),5*yerr.max()])
pl.tight_layout()
pl.show()
\end{python}
The result is shown in Figure \ref{fig:pol2fitexample}.
\begin{poutput}
(* \capfig{0.7\textwidth}{figures/pol2fitexample.png}{\label{fig:pol2fitexample}Example of a fit to a second order polynomial and the residual plot.} *)
\end{poutput}
 